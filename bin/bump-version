#!/usr/bin/env bash
set -euo pipefail

# Bump Version
# Fetch the latest semantic version tag, increment the specified version component,
# create the new tag, and push it to remote.

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

DRY_RUN=false
SKIP_CONFIRM=false
TARGET_BRANCH="main"
REMOTE_NAME=""

usage() {
    echo "Usage: bump-version [OPTIONS] <major|minor|patch>"
    echo ""
    echo "Options:"
    echo "  --dry-run, -n    Show what would be done without making changes"
    echo "  --yes, -y        Skip confirmation prompt"
    echo "  --branch, -b     Base branch to validate/tag from (default: main)"
    echo "  --remote, -r     Remote name to fetch/push (default: origin or first remote)"
    echo ""
    echo "Examples:"
    echo "  bump-version major          # v1.2.3 -> v2.0.0"
    echo "  bump-version minor          # v1.2.3 -> v1.3.0"
    echo "  bump-version patch          # v1.2.3 -> v1.2.4"
    echo "  bump-version --dry-run major"
    echo "  bump-version -y patch"
    exit 1
}

if [ $# -lt 1 ]; then
    usage
fi

# Parse options
while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run|-n)
            DRY_RUN=true
            shift
            ;;
        --yes|-y)
            SKIP_CONFIRM=true
            shift
            ;;
        --branch|-b)
            if [ $# -lt 2 ]; then
                echo "Error: --branch requires a value"
                usage
            fi
            TARGET_BRANCH="$2"
            shift 2
            ;;
        --remote|-r)
            if [ $# -lt 2 ]; then
                echo "Error: --remote requires a value"
                usage
            fi
            REMOTE_NAME="$2"
            shift 2
            ;;
        major|minor|patch)
            bump_type="$1"
            shift
            ;;
        *)
            echo "Error: Invalid argument '$1'"
            usage
            ;;
    esac
done

if [ -z "${bump_type:-}" ]; then
    echo "Error: Version type (major|minor|patch) is required"
    usage
fi

# Determine remote if not provided
if [ -z "$REMOTE_NAME" ]; then
    remotes=$(git remote)
    if echo "$remotes" | grep -qx "origin"; then
        REMOTE_NAME="origin"
    elif [ -n "$remotes" ]; then
        REMOTE_NAME=$(echo "$remotes" | head -n1)
    fi
fi

if [ -z "$REMOTE_NAME" ]; then
    echo -e "${RED}Error: Could not determine git remote. Specify one with --remote.${NC}"
    exit 1
fi

REMOTE_REF="$REMOTE_NAME/$TARGET_BRANCH"

# Check if on target branch
current_branch=$(git branch --show-current)
if [ "$current_branch" != "$TARGET_BRANCH" ]; then
    echo -e "${RED}Error: You must be on the '${TARGET_BRANCH}' branch to bump version.${NC}"
    echo -e "Current branch: ${YELLOW}$current_branch${NC}"
    exit 1
fi

# Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
    echo -e "${RED}Error: You have uncommitted changes in your working directory.${NC}"
    echo -e "Please commit or stash your changes before bumping version."
    git status --short
    exit 1
fi

# Check for untracked files
if [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo -e "${YELLOW}Warning: You have untracked files in your working directory.${NC}"
    git ls-files --others --exclude-standard
    if [ "$SKIP_CONFIRM" = false ] && [ "$DRY_RUN" = false ]; then
        read -p "Continue anyway? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
fi

if [ "$DRY_RUN" = false ]; then
    echo -e "${BLUE}â†’ Fetching from $REMOTE_NAME/$TARGET_BRANCH...${NC}"
    git fetch --tags "$REMOTE_NAME" "$TARGET_BRANCH"
else
    echo -e "${BLUE}â†’ Skipping fetch in dry-run mode (using local refs).${NC}"
fi

echo -e "${BLUE}â†’ Checking synchronization with $REMOTE_REF...${NC}"
if git rev-parse --verify "$REMOTE_REF" >/dev/null 2>&1; then
    read -r behind ahead <<< "$(git rev-list --left-right --count "$REMOTE_REF"...$TARGET_BRANCH)"

    if [ "$behind" -gt 0 ]; then
        echo -e "${RED}Error: Your local '$TARGET_BRANCH' branch is $behind commit(s) behind '$REMOTE_REF'.${NC}"
        echo -e "Please pull the latest changes first: ${CYAN}git pull $REMOTE_NAME $TARGET_BRANCH${NC}"
        exit 1
    fi

    if [ "$ahead" -gt 0 ]; then
        echo -e "${YELLOW}Warning: Your local '$TARGET_BRANCH' branch is $ahead commit(s) ahead of '$REMOTE_REF'.${NC}"
        echo -e "The tag will point to a commit that is not yet on $REMOTE_REF. Push after tagging."
    fi
else
    echo -e "${YELLOW}Warning: Remote branch '$REMOTE_REF' not found locally. Skipping sync check.${NC}"
fi

echo -e "${BLUE}â†’ Finding latest semantic version tag on $TARGET_BRANCH...${NC}"
latest_tag=$(git tag --merged "$TARGET_BRANCH" --list "v*.*.*" | sort -V | tail -n1)

if [ -z "$latest_tag" ]; then
    echo -e "${YELLOW}No semantic version tags found.${NC}"
    case "$bump_type" in
        major)
            new_tag="v1.0.0"
            ;;
        minor)
            new_tag="v0.1.0"
            ;;
        patch)
            new_tag="v0.0.1"
            ;;
    esac
else
    echo -e "Latest tag: ${CYAN}$latest_tag${NC}"

    # Extract version numbers (ignore prerelease/build suffixes)
    version=${latest_tag#v}
    core_version=${version%%[-+]*}
    IFS='.' read -r major minor patch <<< "$core_version"

    if [[ -z ${major:-} || -z ${minor:-} || -z ${patch:-} ]]; then
        echo -e "${RED}Error: Unable to parse semantic version from tag '$latest_tag'.${NC}"
        exit 1
    fi

    # Increment the appropriate version component
    case "$bump_type" in
        major)
            new_major=$((major + 1))
            new_tag="v${new_major}.0.0"
            ;;
        minor)
            new_minor=$((minor + 1))
            new_tag="v${major}.${new_minor}.0"
            ;;
        patch)
            new_patch=$((patch + 1))
            new_tag="v${major}.${minor}.${new_patch}"
            ;;
    esac
fi

if [ "$DRY_RUN" = true ]; then
    echo ""
    echo -e "${YELLOW}${BOLD}DRY RUN${NC}${YELLOW} - No changes will be made${NC}"
    echo -e "Would create tag: ${GREEN}${BOLD}$new_tag${NC}"
    echo -e "Would push tag to: ${CYAN}$REMOTE_NAME${NC}"
    exit 0
fi

# Confirmation prompt
if [ "$SKIP_CONFIRM" = false ]; then
    echo ""
    echo -e "${BOLD}Create and push tag ${GREEN}$new_tag${NC}${BOLD}?${NC}"
    read -p "(y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Aborted.${NC}"
        exit 0
    fi
fi

echo -e "${BLUE}â†’ Creating new tag: ${GREEN}${BOLD}$new_tag${NC}"
if ! git tag -a "$new_tag" -m "Bump $bump_type version to $new_tag"; then
    echo -e "${RED}Error: Failed to create tag.${NC}"
    exit 1
fi

echo -e "${BLUE}â†’ Pushing tag to $REMOTE_NAME...${NC}"
if ! git push "$REMOTE_NAME" "$new_tag"; then
    echo -e "${RED}Error: Failed to push tag to $REMOTE_NAME.${NC}"
    echo -e "The local tag has been created but not pushed."
    echo -e "You can manually push it with: ${CYAN}git push $REMOTE_NAME $new_tag${NC}"
    echo -e "Or delete it with: ${CYAN}git tag -d $new_tag${NC}"
    exit 1
fi

echo ""
echo -e "${GREEN}${BOLD}âœ“ Successfully created and pushed tag $new_tag${NC}"

# Generate Jira comment message with pipeline URL
echo ""
echo -e "${BLUE}â†’ Fetching GitLab pipeline information...${NC}"

# Wait a moment for GitLab to create the pipeline
sleep 2

# Get the latest pipeline for this tag
if command -v glab &> /dev/null; then
    if command -v jq &> /dev/null; then
        pipeline_url=$(glab ci list --ref "$new_tag" --per-page 1 --output json 2>/dev/null | jq -r '.[0].web_url // empty')

        if [ -n "$pipeline_url" ]; then
            # Format the Jira comment message
            jira_message="Release erfolgt mit [$new_tag](${pipeline_url}). ğŸš€"

            echo ""
            echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo -e "${CYAN}${BOLD}Jira Comment Message:${NC}"
            echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo ""
            echo -e "${BOLD}$jira_message${NC}"
            echo ""
            echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        else
            echo -e "${YELLOW}Warning: Could not fetch pipeline URL. Pipeline may still be initializing.${NC}"
            echo -e "You can manually check: ${CYAN}glab ci list --ref $new_tag${NC}"
        fi
    else
        echo -e "${YELLOW}Warning: 'jq' command not found. Install it to auto-generate Jira messages.${NC}"
    fi
else
    echo -e "${YELLOW}Warning: 'glab' command not found. Install it to auto-generate Jira messages.${NC}"
fi
